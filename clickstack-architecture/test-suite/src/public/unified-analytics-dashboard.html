<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í†µí•© ë¶„ì„ ëŒ€ì‹œë³´ë“œ - AIRIS-MON</title>
    <script src="/components/common-layout.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .dashboard-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .dashboard-header h2 {
            font-size: 1.875rem;
            font-weight: 700;
            color: var(--gray-900);
            margin-bottom: 0.5rem;
        }
        
        .dashboard-header .subtitle {
            color: var(--gray-600);
            font-size: 1rem;
        }

        .metrics-overview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .metric-card {
            background: var(--white);
            padding: 1.5rem;
            border-radius: 12px;
            border: 1px solid var(--gray-200);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .metric-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }

        .metric-icon.app {
            background: var(--primary);
            color: white;
        }

        .metric-icon.db {
            background: var(--success);
            color: white;
        }

        .metric-icon.infra {
            background: var(--warning);
            color: white;
        }

        .metric-icon.network {
            background: var(--error);
            color: white;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--gray-900);
            margin-bottom: 0.25rem;
        }

        .metric-label {
            font-size: 0.875rem;
            color: var(--gray-600);
            margin-bottom: 0.5rem;
        }

        .metric-trend {
            font-size: 0.75rem;
            font-weight: 500;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
        }

        .trend-up {
            background: #ecfdf5;
            color: #059669;
        }

        .trend-down {
            background: #fef2f2;
            color: #dc2626;
        }

        .trend-stable {
            background: #f3f4f6;
            color: #6b7280;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .chart-container {
            background: var(--white);
            border: 1px solid var(--gray-200);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .chart-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--gray-900);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .chart-subtitle {
            font-size: 0.875rem;
            color: var(--gray-600);
            margin-bottom: 1.5rem;
        }

        .chart-svg {
            width: 100%;
            height: 300px;
        }

        .detailed-charts {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
        }

        .full-width-chart {
            background: var(--white);
            border: 1px solid var(--gray-200);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .chart-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--gray-700);
        }

        .control-select {
            padding: 0.5rem;
            border: 1px solid var(--gray-200);
            border-radius: 6px;
            font-size: 0.875rem;
            background: var(--white);
        }

        .data-source-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            font-weight: 500;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            margin-left: auto;
        }

        .source-realtime {
            background: #dbeafe;
            color: #1d4ed8;
        }

        .source-aggregated {
            background: #ecfdf5;
            color: #059669;
        }

        .source-mixed {
            background: #fef3c7;
            color: #d97706;
        }

        /* D3.js ì°¨íŠ¸ ìŠ¤íƒ€ì¼ */
        .line {
            fill: none;
            stroke-width: 2;
        }

        .area {
            opacity: 0.3;
        }

        .axis text {
            font-size: 12px;
            fill: #6b7280;
        }

        .axis path,
        .axis line {
            stroke: #d1d5db;
            stroke-width: 1;
        }

        .grid line {
            stroke: #f3f4f6;
            stroke-width: 1;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .legend {
            font-size: 12px;
        }

        .legend-item {
            cursor: pointer;
        }

        .legend-item.disabled {
            opacity: 0.3;
        }

        /* ë°˜ì‘í˜• */
        @media (max-width: 768px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }
            
            .metrics-overview {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .chart-controls {
                flex-direction: column;
                align-items: flex-start;
            }
        }

        /* ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ì• ë‹ˆë©”ì´ì…˜ */
        .updating {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
</head>
<body>
    <div class="dashboard-header">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
            <h2 style="margin: 0;">ğŸ“Š í†µí•© ë¶„ì„ ëŒ€ì‹œë³´ë“œ</h2>
            <a href="/detailed-metrics-dashboard.html" style="
                display: inline-flex;
                align-items: center;
                padding: 8px 16px;
                background: #10b981;
                color: white;
                text-decoration: none;
                border-radius: 6px;
                font-size: 14px;
                font-weight: 500;
                transition: background 0.2s;
            " onmouseover="this.style.background='#059669'" onmouseout="this.style.background='#10b981'">
                ğŸ“ˆ ìƒì„¸ ë©”íŠ¸ë¦­ ëŒ€ì‹œë³´ë“œ
            </a>
        </div>
        <p class="subtitle">MongoDB ì§‘ê³„ ë°ì´í„° + ClickHouse ì‹¤ì‹œê°„ ë°ì´í„° D3.js ì‹œê°í™”</p>
    </div>

    <!-- ì£¼ìš” ë©”íŠ¸ë¦­ ê°œìš” -->
    <div class="metrics-overview">
        <div class="metric-card">
            <div class="metric-icon app">ğŸ“±</div>
            <div class="metric-value" id="appMetricValue">--</div>
            <div class="metric-label">APP í‰ê·  ì‘ë‹µì‹œê°„</div>
            <div class="metric-trend trend-up" id="appMetricTrend">â†— 12% ê°œì„ </div>
        </div>
        
        <div class="metric-card">
            <div class="metric-icon db">ğŸ—„ï¸</div>
            <div class="metric-value" id="dbMetricValue">--</div>
            <div class="metric-label">DB ì¿¼ë¦¬ ì„±ëŠ¥</div>
            <div class="metric-trend trend-stable" id="dbMetricTrend">â†’ ì•ˆì •ì </div>
        </div>
        
        <div class="metric-card">
            <div class="metric-icon infra">ğŸ–¥ï¸</div>
            <div class="metric-value" id="infraMetricValue">--</div>
            <div class="metric-label">INFRA CPU ì‚¬ìš©ë¥ </div>
            <div class="metric-trend trend-down" id="infraMetricTrend">â†˜ 5% ê°ì†Œ</div>
        </div>
        
        <div class="metric-card">
            <div class="metric-icon network">ğŸŒ</div>
            <div class="metric-value" id="networkMetricValue">--</div>
            <div class="metric-label">NETWORK ëŒ€ì—­í­</div>
            <div class="metric-trend trend-up" id="networkMetricTrend">â†— 8% ì¦ê°€</div>
        </div>
    </div>

    <!-- ì£¼ìš” ì°¨íŠ¸ ê·¸ë¦¬ë“œ -->
    <div class="charts-grid">
        <!-- APP ì„±ëŠ¥ íŠ¸ë Œë“œ -->
        <div class="chart-container">
            <div class="chart-title">
                ğŸ“± APP ì„±ëŠ¥ íŠ¸ë Œë“œ
                <div class="data-source-indicator source-mixed">
                    ğŸ”´ ì‹¤ì‹œê°„ + ğŸŸ¢ ì§‘ê³„
                </div>
            </div>
            <div class="chart-subtitle">ì‘ë‹µì‹œê°„, ì²˜ë¦¬ëŸ‰, ì—ëŸ¬ìœ¨ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§</div>
            <svg class="chart-svg" id="appTrendChart"></svg>
        </div>

        <!-- DB ì„±ëŠ¥ ë¶„ì„ -->
        <div class="chart-container">
            <div class="chart-title">
                ğŸ—„ï¸ DB ì„±ëŠ¥ ë¶„ì„
                <div class="data-source-indicator source-aggregated">
                    ğŸŸ¢ MongoDB ì§‘ê³„
                </div>
            </div>
            <div class="chart-subtitle">ì¿¼ë¦¬ ì„±ëŠ¥, ì—°ê²° ìƒíƒœ, TPS ë¶„ì„</div>
            <svg class="chart-svg" id="dbPerformanceChart"></svg>
        </div>

        <!-- ì¸í”„ë¼ ë¦¬ì†ŒìŠ¤ -->
        <div class="chart-container">
            <div class="chart-title">
                ğŸ–¥ï¸ ì¸í”„ë¼ ë¦¬ì†ŒìŠ¤
                <div class="data-source-indicator source-realtime">
                    ğŸ”´ ClickHouse ì‹¤ì‹œê°„
                </div>
            </div>
            <div class="chart-subtitle">CPU, ë©”ëª¨ë¦¬, ë””ìŠ¤í¬ ì‚¬ìš©ëŸ‰ ì‹¤ì‹œê°„ ì¶”ì </div>
            <svg class="chart-svg" id="infraResourceChart"></svg>
        </div>

        <!-- ë„¤íŠ¸ì›Œí¬ ë¶„ì„ -->
        <div class="chart-container">
            <div class="chart-title">
                ğŸŒ ë„¤íŠ¸ì›Œí¬ ë¶„ì„
                <div class="data-source-indicator source-mixed">
                    ğŸ”´ ì‹¤ì‹œê°„ + ğŸŸ¢ ì§‘ê³„
                </div>
            </div>
            <div class="chart-subtitle">ëŒ€ì—­í­, ì§€ì—°ì‹œê°„, íŒ¨í‚· ì†ì‹¤ë¥ </div>
            <svg class="chart-svg" id="networkAnalysisChart"></svg>
        </div>
    </div>

    <!-- ìƒì„¸ ë¶„ì„ ì°¨íŠ¸ -->
    <div class="detailed-charts">
        <!-- í†µí•© ì‹œìŠ¤í…œ ìƒê´€ê´€ê³„ ë¶„ì„ -->
        <div class="full-width-chart">
            <div class="chart-controls">
                <div class="control-group">
                    <label class="control-label">ì‹œê°„ ë²”ìœ„:</label>
                    <select class="control-select" id="timeRangeSelect">
                        <option value="1h">ìµœê·¼ 1ì‹œê°„</option>
                        <option value="6h">ìµœê·¼ 6ì‹œê°„</option>
                        <option value="24h" selected>ìµœê·¼ 24ì‹œê°„</option>
                        <option value="7d">ìµœê·¼ 7ì¼</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">ë°ì´í„° ì†ŒìŠ¤:</label>
                    <select class="control-select" id="dataSourceSelect">
                        <option value="mixed" selected>ì‹¤ì‹œê°„ + ì§‘ê³„</option>
                        <option value="realtime">ClickHouse ì‹¤ì‹œê°„</option>
                        <option value="aggregated">MongoDB ì§‘ê³„</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">ì§‘ê³„ ë‹¨ìœ„:</label>
                    <select class="control-select" id="aggregationSelect">
                        <option value="1m">1ë¶„</option>
                        <option value="5m" selected>5ë¶„</option>
                        <option value="15m">15ë¶„</option>
                        <option value="1h">1ì‹œê°„</option>
                    </select>
                </div>
            </div>
            
            <div class="chart-title">
                ğŸ”— í†µí•© ì‹œìŠ¤í…œ ìƒê´€ê´€ê³„ ë¶„ì„
                <div class="data-source-indicator source-mixed">
                    ğŸŸ¡ í˜¼í•© ë°ì´í„°
                </div>
            </div>
            <div class="chart-subtitle">APP â†” DB â†” INFRA â†” NETWORK ì„±ëŠ¥ ìƒê´€ê´€ê³„ ë° ë³‘ëª© ì§€ì  ë¶„ì„</div>
            <svg class="chart-svg" id="correlationChart" style="height: 400px;"></svg>
        </div>

        <!-- ì´ìƒ íƒì§€ ë° ì˜ˆì¸¡ ë¶„ì„ -->
        <div class="full-width-chart">
            <div class="chart-title">
                ğŸ” ì´ìƒ íƒì§€ ë° ì˜ˆì¸¡ ë¶„ì„
                <div class="data-source-indicator source-mixed">
                    ğŸŸ¡ AI ê¸°ë°˜ ë¶„ì„
                </div>
            </div>
            <div class="chart-subtitle">ì‹¤ì‹œê°„ ì´ìƒ íŒ¨í„´ ê°ì§€ ë° í–¥í›„ ì„±ëŠ¥ ì˜ˆì¸¡</div>
            <svg class="chart-svg" id="anomalyDetectionChart" style="height: 350px;"></svg>
        </div>
    </div>

    <!-- íˆ´íŒ -->
    <div class="tooltip" id="tooltip"></div>

    <script>
        // ì „ì—­ ë³€ìˆ˜
        let dashboardData = {
            app: [],
            db: [],
            infra: [],
            network: [],
            correlation: [],
            anomalies: []
        };

        let updateInterval;
        let isRealTimeMode = true;

        // D3.js ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
        const formatTime = d3.timeFormat("%H:%M");
        const formatDate = d3.timeFormat("%m/%d %H:%M");
        const formatValue = d3.format(".1f");
        const formatPercent = d3.format(".1%");

        // ìƒ‰ìƒ íŒ”ë ˆíŠ¸
        const colorSchemes = {
            app: ['#667eea', '#764ba2', '#f093fb'],
            db: ['#f093fb', '#f5576c', '#4facfe'],
            infra: ['#4facfe', '#00f2fe', '#43e97b'],
            network: ['#43e97b', '#38f9d7', '#667eea']
        };

        // íˆ´íŒ ê´€ë¦¬
        const tooltip = d3.select("#tooltip");

        function showTooltip(event, content) {
            tooltip
                .style("opacity", 1)
                .html(content)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px");
        }

        function hideTooltip() {
            tooltip.style("opacity", 0);
        }

        // ë©”ì¸ ì´ˆê¸°í™” í•¨ìˆ˜
        function initializeDashboard() {
            console.log('ğŸ“Š í†µí•© ë¶„ì„ ëŒ€ì‹œë³´ë“œ ì´ˆê¸°í™” ì‹œì‘...');
            
            // ëª¨ë“  ì°¨íŠ¸ ì´ˆê¸°í™”
            initializeAppTrendChart();
            initializeDBPerformanceChart();
            initializeInfraResourceChart();
            initializeNetworkAnalysisChart();
            initializeCorrelationChart();
            initializeAnomalyDetectionChart();
            
            // ë°ì´í„° ë¡œë“œ ë° ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ì‹œì‘
            loadInitialData();
            startRealTimeUpdates();
            
            // ì»¨íŠ¸ë¡¤ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            setupControlListeners();
            
            console.log('âœ… í†µí•© ë¶„ì„ ëŒ€ì‹œë³´ë“œ ì´ˆê¸°í™” ì™„ë£Œ');
        }

        // APP ì„±ëŠ¥ íŠ¸ë Œë“œ ì°¨íŠ¸ (ë¼ì¸ì°¨íŠ¸ + ì˜ì—­ì°¨íŠ¸)
        function initializeAppTrendChart() {
            const svg = d3.select("#appTrendChart");
            if (!svg.node()) {
                console.error('âŒ APP ì°¨íŠ¸ SVG ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
                return;
            }
            
            const svgRect = svg.node().getBoundingClientRect();
            console.log('ğŸ“Š APP ì°¨íŠ¸ í¬ê¸°:', svgRect.width, 'x', svgRect.height);
            
            const margin = {top: 20, right: 80, bottom: 40, left: 60};
            const width = Math.max(svgRect.width - margin.left - margin.right, 400);
            const height = 300 - margin.top - margin.bottom;

            svg.selectAll("*").remove();

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // ìŠ¤ì¼€ì¼ ì„¤ì •
            const xScale = d3.scaleTime().range([0, width]);
            const yScale = d3.scaleLinear().range([height, 0]);

            // ì¶• ìƒì„±
            const xAxis = d3.axisBottom(xScale).tickFormat(formatTime);
            const yAxis = d3.axisLeft(yScale).tickFormat(d => d + "ms");

            // ê·¸ë¦¬ë“œ ë¼ì¸
            g.append("g")
                .attr("class", "grid")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale).tickSize(-height).tickFormat(""));

            g.append("g")
                .attr("class", "grid")
                .call(d3.axisLeft(yScale).tickSize(-width).tickFormat(""));

            // ì¶• ì¶”ê°€
            g.append("g")
                .attr("class", "axis")
                .attr("transform", `translate(0,${height})`)
                .call(xAxis);

            g.append("g")
                .attr("class", "axis")
                .call(yAxis);

            // ë¼ì¸ ë° ì˜ì—­ ìƒì„±ê¸°
            const line = d3.line()
                .x(d => xScale(d.timestamp))
                .y(d => yScale(d.value))
                .curve(d3.curveMonotoneX);

            const area = d3.area()
                .x(d => xScale(d.timestamp))
                .y0(height)
                .y1(d => yScale(d.value))
                .curve(d3.curveMonotoneX);

            // ë²”ë¡€ ì¶”ê°€
            const legend = g.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(${width - 70}, 20)`);

            legend.append("text")
                .attr("x", 0)
                .attr("y", 0)
                .style("font-size", "12px")
                .style("font-weight", "600")
                .text("ë©”íŠ¸ë¦­");

            // ì´ˆê¸° í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±
            const testData = [];
            const now = new Date();
            for (let i = 0; i < 30; i++) {
                testData.push({
                    timestamp: new Date(now.getTime() - (29 - i) * 60000),
                    value: 150 + Math.random() * 100 + Math.sin(i * 0.5) * 50,
                    source: 'initial'
                });
            }
            
            // ì°¨íŠ¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ë¥¼ ì „ì—­ìœ¼ë¡œ ì €ì¥
            window.updateAppTrendChart = function(data) {
                if (!data || data.length === 0) {
                    console.log('âš ï¸ APP ë°ì´í„° ì—†ìŒ, í…ŒìŠ¤íŠ¸ ë°ì´í„° ì‚¬ìš©');
                    data = testData;
                }

                xScale.domain(d3.extent(data, d => d.timestamp));
                yScale.domain([0, d3.max(data, d => d.value) * 1.1]);

                // ê¸°ì¡´ ê²½ë¡œ ì œê±°
                g.selectAll(".line, .area").remove();

                // ì˜ì—­ ì°¨íŠ¸ ì¶”ê°€
                g.append("path")
                    .datum(data)
                    .attr("class", "area")
                    .attr("d", area)
                    .style("fill", colorSchemes.app[0])
                    .style("opacity", 0.3);

                // ë¼ì¸ ì°¨íŠ¸ ì¶”ê°€
                g.append("path")
                    .datum(data)
                    .attr("class", "line")
                    .attr("d", line)
                    .style("stroke", colorSchemes.app[0]);

                // ì¶• ì—…ë°ì´íŠ¸
                g.select(".axis").transition().duration(500).call(xAxis);
                g.select(".axis:last-child").transition().duration(500).call(yAxis);

                // ì¸í„°ë™ì…˜ í¬ì¸íŠ¸ ì¶”ê°€
                g.selectAll(".dot").remove();
                g.selectAll(".dot")
                    .data(data.filter((d, i) => i % 5 === 0)) // 5ê°œë§ˆë‹¤ ì  í‘œì‹œ
                    .enter().append("circle")
                    .attr("class", "dot")
                    .attr("cx", d => xScale(d.timestamp))
                    .attr("cy", d => yScale(d.value))
                    .attr("r", 3)
                    .style("fill", colorSchemes.app[0])
                    .on("mouseover", function(event, d) {
                        showTooltip(event, `
                            <strong>APP ì‘ë‹µì‹œê°„</strong><br>
                            ì‹œê°„: ${formatDate(d.timestamp)}<br>
                            ê°’: ${formatValue(d.value)}ms<br>
                            ì†ŒìŠ¤: ${d.source || 'ClickHouse'}
                        `);
                    })
                    .on("mouseout", hideTooltip);
            };
            
            // ì´ˆê¸° ì°¨íŠ¸ ê·¸ë¦¬ê¸° (í…ŒìŠ¤íŠ¸ ë°ì´í„°ë¡œ)
            console.log('ğŸ“Š APP ì°¨íŠ¸ ì´ˆê¸° ë Œë”ë§ ì‹¤í–‰...');
            window.updateAppTrendChart(testData);
        }

        // DB ì„±ëŠ¥ ë¶„ì„ ì°¨íŠ¸ (ë©€í‹° ë°” ì°¨íŠ¸)
        function initializeDBPerformanceChart() {
            const svg = d3.select("#dbPerformanceChart");
            if (!svg.node()) {
                console.error('âŒ DB ì°¨íŠ¸ SVG ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
                return;
            }
            
            const margin = {top: 20, right: 20, bottom: 40, left: 60};
            const width = Math.max(svg.node().getBoundingClientRect().width - margin.left - margin.right, 400);
            const height = 300 - margin.top - margin.bottom;

            svg.selectAll("*").remove();

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // ì´ˆê¸° í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±
            const testData = [];
            const now = new Date();
            for (let i = 0; i < 10; i++) {
                testData.push({
                    timestamp: new Date(now.getTime() - (9 - i) * 60000),
                    queryTime: 80 + Math.random() * 40,
                    connections: 20 + Math.random() * 30,
                    tps: 2000 + Math.random() * 1000
                });
            }

            window.updateDBPerformanceChart = function(data) {
                if (!data || data.length === 0) {
                    console.log('âš ï¸ DB ë°ì´í„° ì—†ìŒ, í…ŒìŠ¤íŠ¸ ë°ì´í„° ì‚¬ìš©');
                    data = testData;
                }

                g.selectAll("*").remove();

                const metrics = ['queryTime', 'connections', 'tps'];
                const metricLabels = ['ì¿¼ë¦¬ì‹œê°„', 'ì—°ê²°ìˆ˜', 'TPS'];
                
                const xScale = d3.scaleBand()
                    .domain(data.map(d => formatTime(d.timestamp)))
                    .range([0, width])
                    .padding(0.1);

                const yScale = d3.scaleLinear()
                    .domain([0, d3.max(data, d => Math.max(d.queryTime, d.connections, d.tps / 10))])
                    .range([height, 0]);

                const colorScale = d3.scaleOrdinal()
                    .domain(metrics)
                    .range(colorSchemes.db);

                // ì¶• ì¶”ê°€
                g.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(xScale));

                g.append("g")
                    .attr("class", "axis")
                    .call(d3.axisLeft(yScale));

                // ê·¸ë£¹ë³„ ë°” ì°¨íŠ¸
                const barWidth = xScale.bandwidth() / metrics.length;

                metrics.forEach((metric, i) => {
                    g.selectAll(`.bar-${metric}`)
                        .data(data)
                        .enter().append("rect")
                        .attr("class", `bar-${metric}`)
                        .attr("x", d => xScale(formatTime(d.timestamp)) + barWidth * i)
                        .attr("y", d => yScale(metric === 'tps' ? d[metric] / 10 : d[metric]))
                        .attr("width", barWidth)
                        .attr("height", d => height - yScale(metric === 'tps' ? d[metric] / 10 : d[metric]))
                        .style("fill", colorScale(metric))
                        .on("mouseover", function(event, d) {
                            showTooltip(event, `
                                <strong>DB ${metricLabels[i]}</strong><br>
                                ì‹œê°„: ${formatDate(d.timestamp)}<br>
                                ê°’: ${formatValue(metric === 'tps' ? d[metric] : d[metric])}${metric === 'tps' ? '' : metric === 'connections' ? 'ê°œ' : 'ms'}<br>
                                ì†ŒìŠ¤: MongoDB ì§‘ê³„
                            `);
                        })
                        .on("mouseout", hideTooltip);
                });

                // ë²”ë¡€
                const legend = g.append("g")
                    .attr("class", "legend")
                    .attr("transform", `translate(${width - 100}, 20)`);

                metricLabels.forEach((label, i) => {
                    const legendItem = legend.append("g")
                        .attr("transform", `translate(0, ${i * 20})`);

                    legendItem.append("rect")
                        .attr("width", 12)
                        .attr("height", 12)
                        .style("fill", colorScale(metrics[i]));

                    legendItem.append("text")
                        .attr("x", 18)
                        .attr("y", 9)
                        .style("font-size", "11px")
                        .text(label);
                });
            };
            
            // ì´ˆê¸° ì°¨íŠ¸ ê·¸ë¦¬ê¸° (í…ŒìŠ¤íŠ¸ ë°ì´í„°ë¡œ)
            console.log('ğŸ“Š DB ì°¨íŠ¸ ì´ˆê¸° ë Œë”ë§ ì‹¤í–‰...');
            window.updateDBPerformanceChart(testData);
        }

        // ì¸í”„ë¼ ë¦¬ì†ŒìŠ¤ ì°¨íŠ¸ (ìŠ¤íƒ ì˜ì—­ ì°¨íŠ¸)
        function initializeInfraResourceChart() {
            const svg = d3.select("#infraResourceChart");
            if (!svg.node()) {
                console.error('âŒ INFRA ì°¨íŠ¸ SVG ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
                return;
            }
            
            const margin = {top: 20, right: 20, bottom: 40, left: 60};
            const width = Math.max(svg.node().getBoundingClientRect().width - margin.left - margin.right, 400);
            const height = 300 - margin.top - margin.bottom;

            svg.selectAll("*").remove();

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // ì´ˆê¸° í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±
            const testData = [];
            const now = new Date();
            for (let i = 0; i < 20; i++) {
                testData.push({
                    timestamp: new Date(now.getTime() - (19 - i) * 60000),
                    cpu: 30 + Math.random() * 40,
                    memory: 40 + Math.random() * 30,
                    disk: 20 + Math.random() * 25
                });
            }

            window.updateInfraResourceChart = function(data) {
                if (!data || data.length === 0) {
                    console.log('âš ï¸ INFRA ë°ì´í„° ì—†ìŒ, í…ŒìŠ¤íŠ¸ ë°ì´í„° ì‚¬ìš©');
                    data = testData;
                }

                g.selectAll("*").remove();

                const keys = ['cpu', 'memory', 'disk'];
                const stack = d3.stack().keys(keys);
                const stackedData = stack(data);

                const xScale = d3.scaleTime()
                    .domain(d3.extent(data, d => d.timestamp))
                    .range([0, width]);

                const yScale = d3.scaleLinear()
                    .domain([0, 100])
                    .range([height, 0]);

                const colorScale = d3.scaleOrdinal()
                    .domain(keys)
                    .range(colorSchemes.infra);

                const area = d3.area()
                    .x(d => xScale(d.data.timestamp))
                    .y0(d => yScale(d[0]))
                    .y1(d => yScale(d[1]))
                    .curve(d3.curveMonotoneX);

                // ì¶• ì¶”ê°€
                g.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(xScale).tickFormat(formatTime));

                g.append("g")
                    .attr("class", "axis")
                    .call(d3.axisLeft(yScale).tickFormat(d => d + "%"));

                // ìŠ¤íƒ ì˜ì—­ ì¶”ê°€
                g.selectAll(".area")
                    .data(stackedData)
                    .enter().append("path")
                    .attr("class", "area")
                    .attr("d", area)
                    .style("fill", d => colorScale(d.key))
                    .on("mouseover", function(event, d) {
                        const values = d[Math.floor(d.length / 2)];
                        showTooltip(event, `
                            <strong>INFRA ${d.key.toUpperCase()}</strong><br>
                            ì‹œê°„: ${formatDate(values.data.timestamp)}<br>
                            ì‚¬ìš©ë¥ : ${formatValue(values[1] - values[0])}%<br>
                            ì†ŒìŠ¤: ClickHouse ì‹¤ì‹œê°„
                        `);
                    })
                    .on("mouseout", hideTooltip);
            };
            
            // ì´ˆê¸° ì°¨íŠ¸ ê·¸ë¦¬ê¸° (í…ŒìŠ¤íŠ¸ ë°ì´í„°ë¡œ)
            console.log('ğŸ“Š INFRA ì°¨íŠ¸ ì´ˆê¸° ë Œë”ë§ ì‹¤í–‰...');
            window.updateInfraResourceChart(testData);
        }

        // ë„¤íŠ¸ì›Œí¬ ë¶„ì„ ì°¨íŠ¸ (ë ˆì´ë” ì°¨íŠ¸)
        function initializeNetworkAnalysisChart() {
            const svg = d3.select("#networkAnalysisChart");
            if (!svg.node()) {
                console.error('âŒ NETWORK ì°¨íŠ¸ SVG ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!');
                return;
            }
            
            const margin = {top: 40, right: 40, bottom: 40, left: 40};
            const width = Math.max(svg.node().getBoundingClientRect().width - margin.left - margin.right, 400);
            const height = 300 - margin.top - margin.bottom;
            const radius = Math.min(width, height) / 2;

            svg.selectAll("*").remove();

            const g = svg.append("g")
                .attr("transform", `translate(${width/2 + margin.left},${height/2 + margin.top})`);
            
            // ì´ˆê¸° í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±
            const testData = [{
                timestamp: new Date(),
                bandwidth: 75 + Math.random() * 20,
                latency: 20 + Math.random() * 30,
                packetLoss: Math.random() * 5,
                throughput: 60 + Math.random() * 30
            }];

            window.updateNetworkAnalysisChart = function(data) {
                if (!data || data.length === 0) {
                    console.log('âš ï¸ NETWORK ë°ì´í„° ì—†ìŒ, í…ŒìŠ¤íŠ¸ ë°ì´í„° ì‚¬ìš©');
                    data = testData;
                }

                g.selectAll("*").remove();

                const metrics = ['bandwidth', 'latency', 'packetLoss', 'throughput'];
                const angleSlice = Math.PI * 2 / metrics.length;

                // ë°©ì‚¬í˜• ìŠ¤ì¼€ì¼
                const rScale = d3.scaleLinear()
                    .domain([0, 100])
                    .range([0, radius]);

                // ê·¸ë¦¬ë“œ ë¼ì¸
                for (let i = 1; i <= 5; i++) {
                    g.append("circle")
                        .attr("r", radius * i / 5)
                        .style("fill", "none")
                        .style("stroke", "#f3f4f6")
                        .style("stroke-width", 1);

                    g.append("text")
                        .attr("x", 5)
                        .attr("y", -radius * i / 5)
                        .style("font-size", "10px")
                        .style("fill", "#6b7280")
                        .text(20 * i);
                }

                // ì¶• ë¼ì¸
                metrics.forEach((metric, i) => {
                    const angle = angleSlice * i - Math.PI / 2;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;

                    g.append("line")
                        .attr("x1", 0)
                        .attr("y1", 0)
                        .attr("x2", x)
                        .attr("y2", y)
                        .style("stroke", "#d1d5db")
                        .style("stroke-width", 1);

                    // ë¼ë²¨
                    const labelX = Math.cos(angle) * (radius + 20);
                    const labelY = Math.sin(angle) * (radius + 20);

                    g.append("text")
                        .attr("x", labelX)
                        .attr("y", labelY)
                        .style("font-size", "11px")
                        .style("text-anchor", "middle")
                        .style("fill", "#374151")
                        .text(metric === 'packetLoss' ? 'Packet Loss' : 
                              metric === 'bandwidth' ? 'Bandwidth' :
                              metric === 'latency' ? 'Latency' : 'Throughput');
                });

                // ìµœì‹  ë°ì´í„°ë¡œ ë ˆì´ë” ì°¨íŠ¸ ìƒì„±
                const latestData = data[data.length - 1];
                const radarData = metrics.map((metric, i) => {
                    const angle = angleSlice * i - Math.PI / 2;
                    const value = rScale(latestData[metric] || 0);
                    return {
                        x: Math.cos(angle) * value,
                        y: Math.sin(angle) * value,
                        metric: metric,
                        value: latestData[metric] || 0
                    };
                });

                // ë ˆì´ë” ì˜ì—­
                const radarLine = d3.line()
                    .x(d => d.x)
                    .y(d => d.y)
                    .curve(d3.curveLinearClosed);

                g.append("path")
                    .datum(radarData)
                    .attr("d", radarLine)
                    .style("fill", colorSchemes.network[0])
                    .style("opacity", 0.3)
                    .style("stroke", colorSchemes.network[0])
                    .style("stroke-width", 2);

                // ë°ì´í„° í¬ì¸íŠ¸
                g.selectAll(".radar-dot")
                    .data(radarData)
                    .enter().append("circle")
                    .attr("class", "radar-dot")
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y)
                    .attr("r", 4)
                    .style("fill", colorSchemes.network[1])
                    .on("mouseover", function(event, d) {
                        showTooltip(event, `
                            <strong>NETWORK ${d.metric.toUpperCase()}</strong><br>
                            ê°’: ${formatValue(d.value)}${d.metric === 'latency' ? 'ms' : d.metric === 'bandwidth' ? 'Mbps' : '%'}<br>
                            ì†ŒìŠ¤: í˜¼í•© ë°ì´í„°
                        `);
                    })
                    .on("mouseout", hideTooltip);
            };
            
            // ì´ˆê¸° ì°¨íŠ¸ ê·¸ë¦¬ê¸° (í…ŒìŠ¤íŠ¸ ë°ì´í„°ë¡œ)
            console.log('ğŸ“Š NETWORK ì°¨íŠ¸ ì´ˆê¸° ë Œë”ë§ ì‹¤í–‰...');
            window.updateNetworkAnalysisChart(testData);
        }

        // ìƒê´€ê´€ê³„ ë¶„ì„ ì°¨íŠ¸ (íˆíŠ¸ë§µ)
        function initializeCorrelationChart() {
            const svg = d3.select("#correlationChart");
            const margin = {top: 40, right: 100, bottom: 80, left: 100};
            const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            svg.selectAll("*").remove();

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            window.updateCorrelationChart = function(correlationMatrix) {
                g.selectAll("*").remove();

                const categories = ['APP', 'DB', 'INFRA', 'NETWORK'];
                const cellSize = Math.min(width, height) / categories.length;

                // ìƒ‰ìƒ ìŠ¤ì¼€ì¼
                const colorScale = d3.scaleSequential(d3.interpolateRdYlBu)
                    .domain([-1, 1]);

                // ëª¨ì˜ ìƒê´€ê´€ê³„ ë°ì´í„° ìƒì„±
                const correlation = [
                    [1.0, -0.6, 0.8, 0.3],
                    [-0.6, 1.0, -0.4, 0.7],
                    [0.8, -0.4, 1.0, 0.2],
                    [0.3, 0.7, 0.2, 1.0]
                ];

                // íˆíŠ¸ë§µ ì…€
                categories.forEach((rowCategory, i) => {
                    categories.forEach((colCategory, j) => {
                        const cell = g.append("rect")
                            .attr("x", j * cellSize)
                            .attr("y", i * cellSize)
                            .attr("width", cellSize)
                            .attr("height", cellSize)
                            .style("fill", colorScale(correlation[i][j]))
                            .style("stroke", "white")
                            .style("stroke-width", 2)
                            .on("mouseover", function(event) {
                                showTooltip(event, `
                                    <strong>${rowCategory} â†” ${colCategory}</strong><br>
                                    ìƒê´€ê³„ìˆ˜: ${formatValue(correlation[i][j])}<br>
                                    ${Math.abs(correlation[i][j]) > 0.7 ? 'ê°•í•œ ìƒê´€ê´€ê³„' : 
                                      Math.abs(correlation[i][j]) > 0.3 ? 'ì¤‘ê°„ ìƒê´€ê´€ê³„' : 'ì•½í•œ ìƒê´€ê´€ê³„'}
                                `);
                            })
                            .on("mouseout", hideTooltip);

                        // ìƒê´€ê³„ìˆ˜ ê°’ í‘œì‹œ
                        g.append("text")
                            .attr("x", j * cellSize + cellSize / 2)
                            .attr("y", i * cellSize + cellSize / 2)
                            .attr("text-anchor", "middle")
                            .attr("dominant-baseline", "middle")
                            .style("font-size", "14px")
                            .style("font-weight", "600")
                            .style("fill", Math.abs(correlation[i][j]) > 0.5 ? "white" : "black")
                            .text(formatValue(correlation[i][j]));
                    });
                });

                // ë¼ë²¨
                categories.forEach((category, i) => {
                    // í–‰ ë¼ë²¨
                    g.append("text")
                        .attr("x", -10)
                        .attr("y", i * cellSize + cellSize / 2)
                        .attr("text-anchor", "end")
                        .attr("dominant-baseline", "middle")
                        .style("font-size", "14px")
                        .style("font-weight", "600")
                        .text(category);

                    // ì—´ ë¼ë²¨
                    g.append("text")
                        .attr("x", i * cellSize + cellSize / 2)
                        .attr("y", -10)
                        .attr("text-anchor", "middle")
                        .attr("dominant-baseline", "middle")
                        .style("font-size", "14px")
                        .style("font-weight", "600")
                        .text(category);
                });

                // ìƒ‰ìƒ ë²”ë¡€
                const legendScale = d3.scaleLinear()
                    .domain([-1, 1])
                    .range([0, 200]);

                const legendAxis = d3.axisBottom(legendScale)
                    .tickFormat(d3.format(".1f"));

                const legend = g.append("g")
                    .attr("transform", `translate(${width + 20}, 50)`);

                const legendGradient = svg.append("defs")
                    .append("linearGradient")
                    .attr("id", "correlation-gradient")
                    .attr("x1", "0%")
                    .attr("x2", "0%")
                    .attr("y1", "0%")
                    .attr("y2", "100%");

                legendGradient.selectAll("stop")
                    .data(d3.range(-1, 1.1, 0.1))
                    .enter().append("stop")
                    .attr("offset", d => ((d + 1) / 2) * 100 + "%")
                    .attr("stop-color", d => colorScale(d));

                legend.append("rect")
                    .attr("width", 20)
                    .attr("height", 200)
                    .style("fill", "url(#correlation-gradient)");

                legend.append("g")
                    .attr("transform", `translate(25, 200)`)
                    .call(legendAxis);

                legend.append("text")
                    .attr("x", 10)
                    .attr("y", -10)
                    .style("font-size", "12px")
                    .style("text-anchor", "middle")
                    .text("ìƒê´€ê³„ìˆ˜");
            };
        }

        // ì´ìƒ íƒì§€ ì°¨íŠ¸ (ì‚°ì ë„ + ì‹œê³„ì—´)
        function initializeAnomalyDetectionChart() {
            const svg = d3.select("#anomalyDetectionChart");
            const margin = {top: 20, right: 20, bottom: 40, left: 60};
            const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = 350 - margin.top - margin.bottom;

            svg.selectAll("*").remove();

            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            window.updateAnomalyDetectionChart = function(data) {
                if (!data || data.length === 0) return;

                g.selectAll("*").remove();

                const xScale = d3.scaleTime()
                    .domain(d3.extent(data, d => d.timestamp))
                    .range([0, width]);

                const yScale = d3.scaleLinear()
                    .domain(d3.extent(data, d => d.value))
                    .range([height, 0]);

                // ì¶• ì¶”ê°€
                g.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(xScale).tickFormat(formatTime));

                g.append("g")
                    .attr("class", "axis")
                    .call(d3.axisLeft(yScale));

                // ì •ìƒ ë²”ìœ„ ì˜ì—­
                const normalRange = g.append("g").attr("class", "normal-range");
                
                const meanValue = d3.mean(data, d => d.value);
                const stdDev = d3.deviation(data, d => d.value);
                
                normalRange.append("rect")
                    .attr("x", 0)
                    .attr("y", yScale(meanValue + 2 * stdDev))
                    .attr("width", width)
                    .attr("height", yScale(meanValue - 2 * stdDev) - yScale(meanValue + 2 * stdDev))
                    .style("fill", "#ecfdf5")
                    .style("opacity", 0.5);

                // ë°ì´í„° í¬ì¸íŠ¸
                g.selectAll(".data-point")
                    .data(data)
                    .enter().append("circle")
                    .attr("class", "data-point")
                    .attr("cx", d => xScale(d.timestamp))
                    .attr("cy", d => yScale(d.value))
                    .attr("r", d => d.isAnomaly ? 5 : 3)
                    .style("fill", d => d.isAnomaly ? "#ef4444" : "#3b82f6")
                    .style("stroke", d => d.isAnomaly ? "#dc2626" : "#2563eb")
                    .style("stroke-width", d => d.isAnomaly ? 2 : 1)
                    .on("mouseover", function(event, d) {
                        showTooltip(event, `
                            <strong>${d.isAnomaly ? 'ğŸš¨ ì´ìƒì¹˜ ê°ì§€' : 'ğŸ“Š ì •ìƒ ë°ì´í„°'}</strong><br>
                            ì‹œê°„: ${formatDate(d.timestamp)}<br>
                            ê°’: ${formatValue(d.value)}<br>
                            ${d.isAnomaly ? `ì´ìƒì ìˆ˜: ${formatValue(d.anomalyScore)}` : ''}
                        `);
                    })
                    .on("mouseout", hideTooltip);

                // íŠ¸ë Œë“œ ë¼ì¸
                const lineGenerator = d3.line()
                    .x(d => xScale(d.timestamp))
                    .y(d => yScale(d.predicted || d.value))
                    .curve(d3.curveMonotoneX);

                g.append("path")
                    .datum(data)
                    .attr("class", "trend-line")
                    .attr("d", lineGenerator)
                    .style("fill", "none")
                    .style("stroke", "#8b5cf6")
                    .style("stroke-width", 2)
                    .style("stroke-dasharray", "5,5");

                // ë²”ë¡€
                const legend = g.append("g")
                    .attr("class", "legend")
                    .attr("transform", `translate(${width - 120}, 20)`);

                const legendData = [
                    {label: "ì •ìƒ", color: "#3b82f6"},
                    {label: "ì´ìƒì¹˜", color: "#ef4444"},
                    {label: "ì˜ˆì¸¡", color: "#8b5cf6"}
                ];

                legendData.forEach((item, i) => {
                    const legendItem = legend.append("g")
                        .attr("transform", `translate(0, ${i * 20})`);

                    if (item.label === "ì˜ˆì¸¡") {
                        legendItem.append("line")
                            .attr("x1", 0)
                            .attr("x2", 15)
                            .attr("y1", 5)
                            .attr("y2", 5)
                            .style("stroke", item.color)
                            .style("stroke-width", 2)
                            .style("stroke-dasharray", "3,3");
                    } else {
                        legendItem.append("circle")
                            .attr("cx", 7)
                            .attr("cy", 5)
                            .attr("r", item.label === "ì´ìƒì¹˜" ? 5 : 3)
                            .style("fill", item.color);
                    }

                    legendItem.append("text")
                        .attr("x", 20)
                        .attr("y", 9)
                        .style("font-size", "11px")
                        .text(item.label);
                });
            };
        }

        // ë°ì´í„° ë¡œë“œ í•¨ìˆ˜ë“¤
        async function loadInitialData() {
            console.log('ğŸ“Š ì´ˆê¸° ë°ì´í„° ë¡œë“œ ì‹œì‘...');
            
            try {
                // ì‹¤ì œ APIì—ì„œ ë°ì´í„° ë¡œë“œ (í˜„ì¬ëŠ” ëª¨ì˜ ë°ì´í„°)
                await Promise.all([
                    loadAppData(),
                    loadDBData(), 
                    loadInfraData(),
                    loadNetworkData(),
                    loadCorrelationData(),
                    loadAnomalyData()
                ]);
                
                updateAllCharts();
                updateMetricCards();
                
                console.log('âœ… ì´ˆê¸° ë°ì´í„° ë¡œë“œ ì™„ë£Œ');
            } catch (error) {
                console.error('âŒ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
            }
        }

        // ê°œë³„ ë°ì´í„° ë¡œë“œ í•¨ìˆ˜ë“¤
        async function loadAppData() {
            try {
                const timeRange = document.getElementById('timeRangeSelect')?.value || '24h';
                const dataSource = document.getElementById('dataSourceSelect')?.value || 'mixed';
                
                const response = await fetch(`/api/analytics/app-metrics?timeRange=${timeRange}&source=${dataSource}`);
                const result = await response.json();
                
                if (result.success) {
                    dashboardData.app = result.data.map(item => ({
                        ...item,
                        timestamp: new Date(item.timestamp)
                    }));
                    console.log('âœ… APP ë°ì´í„° ë¡œë“œ ì™„ë£Œ:', result.metadata);
                } else {
                    throw new Error(result.error || 'APP ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨');
                }
            } catch (error) {
                console.error('âŒ APP ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
                // í´ë°±: ë¡œì»¬ ëª¨ì˜ ë°ì´í„°
                loadAppDataFallback();
            }
        }
        
        function loadAppDataFallback() {
            const mockData = [];
            const now = new Date();
            
            for (let i = 30; i >= 0; i--) {
                mockData.push({
                    timestamp: new Date(now.getTime() - i * 60000),
                    value: 150 + Math.random() * 100 + Math.sin(i * 0.1) * 20,
                    source: i < 10 ? 'clickhouse' : 'mongodb'
                });
            }
            
            dashboardData.app = mockData;
        }

        async function loadDBData() {
            try {
                const timeRange = document.getElementById('timeRangeSelect')?.value || '24h';
                
                const response = await fetch(`/api/analytics/db-metrics?timeRange=${timeRange}`);
                const result = await response.json();
                
                if (result.success) {
                    dashboardData.db = result.data.map(item => ({
                        ...item,
                        timestamp: new Date(item.timestamp)
                    }));
                    console.log('âœ… DB ë°ì´í„° ë¡œë“œ ì™„ë£Œ:', result.metadata);
                } else {
                    throw new Error(result.error || 'DB ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨');
                }
            } catch (error) {
                console.error('âŒ DB ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
                // í´ë°±: ë¡œì»¬ ëª¨ì˜ ë°ì´í„°
                loadDBDataFallback();
            }
        }
        
        function loadDBDataFallback() {
            const mockData = [];
            const now = new Date();
            
            for (let i = 20; i >= 0; i--) {
                mockData.push({
                    timestamp: new Date(now.getTime() - i * 300000), // 5ë¶„ ê°„ê²©
                    queryTime: 80 + Math.random() * 40,
                    connections: 20 + Math.random() * 30,
                    tps: 2000 + Math.random() * 1000
                });
            }
            
            dashboardData.db = mockData;
        }

        async function loadInfraData() {
            try {
                const timeRange = document.getElementById('timeRangeSelect')?.value || '24h';
                
                const response = await fetch(`/api/analytics/infra-metrics?timeRange=${timeRange}`);
                const result = await response.json();
                
                if (result.success) {
                    dashboardData.infra = result.data.map(item => ({
                        ...item,
                        timestamp: new Date(item.timestamp)
                    }));
                    console.log('âœ… INFRA ë°ì´í„° ë¡œë“œ ì™„ë£Œ:', result.metadata);
                } else {
                    throw new Error(result.error || 'INFRA ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨');
                }
            } catch (error) {
                console.error('âŒ INFRA ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
                // í´ë°±: ë¡œì»¬ ëª¨ì˜ ë°ì´í„°
                loadInfraDataFallback();
            }
        }
        
        function loadInfraDataFallback() {
            const mockData = [];
            const now = new Date();
            
            for (let i = 30; i >= 0; i--) {
                const cpu = 30 + Math.random() * 40;
                const memory = 40 + Math.random() * 30;
                const disk = 20 + Math.random() * 25;
                
                mockData.push({
                    timestamp: new Date(now.getTime() - i * 60000),
                    cpu: cpu,
                    memory: memory,
                    disk: disk
                });
            }
            
            dashboardData.infra = mockData;
        }

        async function loadNetworkData() {
            try {
                const timeRange = document.getElementById('timeRangeSelect')?.value || '24h';
                
                const response = await fetch(`/api/analytics/network-metrics?timeRange=${timeRange}`);
                const result = await response.json();
                
                if (result.success) {
                    dashboardData.network = result.data.map(item => ({
                        ...item,
                        timestamp: new Date(item.timestamp)
                    }));
                    console.log('âœ… NETWORK ë°ì´í„° ë¡œë“œ ì™„ë£Œ:', result.metadata);
                } else {
                    throw new Error(result.error || 'NETWORK ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨');
                }
            } catch (error) {
                console.error('âŒ NETWORK ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
                // í´ë°±: ë¡œì»¬ ëª¨ì˜ ë°ì´í„°
                loadNetworkDataFallback();
            }
        }
        
        function loadNetworkDataFallback() {
            const mockData = [];
            const now = new Date();
            
            for (let i = 20; i >= 0; i--) {
                mockData.push({
                    timestamp: new Date(now.getTime() - i * 120000), // 2ë¶„ ê°„ê²©
                    bandwidth: 70 + Math.random() * 20,
                    latency: 20 + Math.random() * 30,
                    packetLoss: Math.random() * 5,
                    throughput: 80 + Math.random() * 15
                });
            }
            
            dashboardData.network = mockData;
        }

        async function loadCorrelationData() {
            try {
                const response = await fetch('/api/analytics/correlation-matrix');
                const result = await response.json();
                
                if (result.success) {
                    dashboardData.correlation = result.data;
                    console.log('âœ… ìƒê´€ê´€ê³„ ë°ì´í„° ë¡œë“œ ì™„ë£Œ:', result.data.correlationStrength);
                } else {
                    throw new Error(result.error || 'ìƒê´€ê´€ê³„ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨');
                }
            } catch (error) {
                console.error('âŒ ìƒê´€ê´€ê³„ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
                // í´ë°±: ë¡œì»¬ ëª¨ì˜ ë°ì´í„°
                loadCorrelationDataFallback();
            }
        }
        
        function loadCorrelationDataFallback() {
            dashboardData.correlation = {
                matrix: [
                    [1.0, -0.6, 0.8, 0.3],
                    [-0.6, 1.0, -0.4, 0.7],
                    [0.8, -0.4, 1.0, 0.2],
                    [0.3, 0.7, 0.2, 1.0]
                ],
                categories: ['APP', 'DB', 'INFRA', 'NETWORK']
            };
        }

        async function loadAnomalyData() {
            try {
                const timeRange = document.getElementById('timeRangeSelect')?.value || '24h';
                
                const response = await fetch(`/api/analytics/anomaly-detection?timeRange=${timeRange}`);
                const result = await response.json();
                
                if (result.success) {
                    dashboardData.anomalies = result.data.map(item => ({
                        ...item,
                        timestamp: new Date(item.timestamp)
                    }));
                    console.log('âœ… ì´ìƒ íƒì§€ ë°ì´í„° ë¡œë“œ ì™„ë£Œ:', result.metadata);
                } else {
                    throw new Error(result.error || 'ì´ìƒ íƒì§€ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨');
                }
            } catch (error) {
                console.error('âŒ ì´ìƒ íƒì§€ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
                // í´ë°±: ë¡œì»¬ ëª¨ì˜ ë°ì´í„°
                loadAnomalyDataFallback();
            }
        }
        
        function loadAnomalyDataFallback() {
            const mockData = [];
            const now = new Date();
            
            for (let i = 60; i >= 0; i--) {
                const baseValue = 100 + Math.sin(i * 0.1) * 20;
                const isAnomaly = Math.random() < 0.1; // 10% í™•ë¥ ë¡œ ì´ìƒì¹˜
                const value = isAnomaly ? baseValue + (Math.random() - 0.5) * 100 : baseValue + (Math.random() - 0.5) * 20;
                
                mockData.push({
                    timestamp: new Date(now.getTime() - i * 60000),
                    value: value,
                    predicted: baseValue,
                    isAnomaly: isAnomaly,
                    anomalyScore: isAnomaly ? 0.7 + Math.random() * 0.3 : Math.random() * 0.3
                });
            }
            
            dashboardData.anomalies = mockData;
        }

        // ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        function updateAllCharts() {
            if (window.updateAppTrendChart) window.updateAppTrendChart(dashboardData.app);
            if (window.updateDBPerformanceChart) window.updateDBPerformanceChart(dashboardData.db);
            if (window.updateInfraResourceChart) window.updateInfraResourceChart(dashboardData.infra);
            if (window.updateNetworkAnalysisChart) window.updateNetworkAnalysisChart(dashboardData.network);
            if (window.updateCorrelationChart) window.updateCorrelationChart(dashboardData.correlation);
            if (window.updateAnomalyDetectionChart) window.updateAnomalyDetectionChart(dashboardData.anomalies);
        }

        // ë©”íŠ¸ë¦­ ì¹´ë“œ ì—…ë°ì´íŠ¸ (API ë°ì´í„° ê¸°ë°˜)
        async function updateMetricCards() {
            try {
                const response = await fetch('/api/analytics/metrics-summary');
                const result = await response.json();
                
                if (result.success) {
                    const data = result.data;
                    
                    // APP ë©”íŠ¸ë¦­
                    document.getElementById('appMetricValue').textContent = formatValue(data.app.responseTime) + 'ms';
                    const appTrend = document.getElementById('appMetricTrend');
                    appTrend.className = `metric-trend trend-${data.app.trend}`;
                    appTrend.textContent = data.app.trend === 'up' ? 'â†— ê°œì„ ' : data.app.trend === 'down' ? 'â†˜ ì•…í™”' : 'â†’ ì•ˆì •ì ';
                    
                    // DB ë©”íŠ¸ë¦­
                    document.getElementById('dbMetricValue').textContent = formatValue(data.db.queryTime) + 'ms';
                    const dbTrend = document.getElementById('dbMetricTrend');
                    dbTrend.className = `metric-trend trend-${data.db.trend}`;
                    dbTrend.textContent = data.db.trend === 'up' ? 'â†— ì¦ê°€' : data.db.trend === 'down' ? 'â†˜ ê°ì†Œ' : 'â†’ ì•ˆì •ì ';
                    
                    // INFRA ë©”íŠ¸ë¦­
                    document.getElementById('infraMetricValue').textContent = formatValue(data.infra.cpuUsage) + '%';
                    const infraTrend = document.getElementById('infraMetricTrend');
                    infraTrend.className = `metric-trend trend-${data.infra.trend}`;
                    infraTrend.textContent = data.infra.trend === 'up' ? 'â†— ì¦ê°€' : data.infra.trend === 'down' ? 'â†˜ ê°ì†Œ' : 'â†’ ì•ˆì •ì ';
                    
                    // NETWORK ë©”íŠ¸ë¦­
                    document.getElementById('networkMetricValue').textContent = formatValue(data.network.bandwidth) + 'Mbps';
                    const networkTrend = document.getElementById('networkMetricTrend');
                    networkTrend.className = `metric-trend trend-${data.network.trend}`;
                    networkTrend.textContent = data.network.trend === 'up' ? 'â†— ì¦ê°€' : data.network.trend === 'down' ? 'â†˜ ê°ì†Œ' : 'â†’ ì•ˆì •ì ';
                    
                    console.log('âœ… ë©”íŠ¸ë¦­ ì¹´ë“œ ì—…ë°ì´íŠ¸ ì™„ë£Œ');
                } else {
                    throw new Error(result.error || 'ë©”íŠ¸ë¦­ ìš”ì•½ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨');
                }
            } catch (error) {
                console.error('âŒ ë©”íŠ¸ë¦­ ì¹´ë“œ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', error);
                // í´ë°±: ê¸°ì¡´ ë¡œì§
                updateMetricCardsFallback();
            }
        }
        
        function updateMetricCardsFallback() {
            if (dashboardData.app.length > 0) {
                const latest = dashboardData.app[dashboardData.app.length - 1];
                document.getElementById('appMetricValue').textContent = formatValue(latest.value || latest.responseTime) + 'ms';
            }
            
            if (dashboardData.db.length > 0) {
                const latest = dashboardData.db[dashboardData.db.length - 1];
                document.getElementById('dbMetricValue').textContent = formatValue(latest.queryTime) + 'ms';
            }
            
            if (dashboardData.infra.length > 0) {
                const latest = dashboardData.infra[dashboardData.infra.length - 1];
                document.getElementById('infraMetricValue').textContent = formatValue(latest.cpu) + '%';
            }
            
            if (dashboardData.network.length > 0) {
                const latest = dashboardData.network[dashboardData.network.length - 1];
                document.getElementById('networkMetricValue').textContent = formatValue(latest.bandwidth) + 'Mbps';
            }
        }

        // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ (API ê¸°ë°˜)
        function startRealTimeUpdates() {
            updateInterval = setInterval(async () => {
                if (isRealTimeMode) {
                    console.log('ğŸ”„ ì‹¤ì‹œê°„ ë°ì´í„° ì—…ë°ì´íŠ¸ ì‹œì‘...');
                    
                    try {
                        // ìƒˆë¡œìš´ APP ë°ì´í„° í•œ ê°œì”© ì¶”ê°€ (ì‹¤ì‹œê°„ ì‹œë®¬ë ˆì´ì…˜)
                        const appResponse = await fetch('/api/analytics/app-metrics?timeRange=1h&source=realtime');
                        if (appResponse.ok) {
                            const appResult = await appResponse.json();
                            if (appResult.success && appResult.data.length > 0) {
                                const latestApp = appResult.data[appResult.data.length - 1];
                                latestApp.timestamp = new Date();
                                dashboardData.app.push(latestApp);
                                if (dashboardData.app.length > 50) dashboardData.app.shift();
                            }
                        }
                        
                        // ì¸í”„ë¼ ë°ì´í„° ì—…ë°ì´íŠ¸ (ClickHouse ì‹¤ì‹œê°„)
                        const infraResponse = await fetch('/api/analytics/infra-metrics?timeRange=1h');
                        if (infraResponse.ok) {
                            const infraResult = await infraResponse.json();
                            if (infraResult.success && infraResult.data.length > 0) {
                                const latestInfra = infraResult.data[infraResult.data.length - 1];
                                latestInfra.timestamp = new Date();
                                dashboardData.infra.push(latestInfra);
                                if (dashboardData.infra.length > 60) dashboardData.infra.shift();
                            }
                        }
                        
                        // ë„¤íŠ¸ì›Œí¬ ë°ì´í„° ì—…ë°ì´íŠ¸ (ì£¼ê¸°ì )
                        if (Math.random() < 0.6) { // 60% í™•ë¥ ë¡œ ì—…ë°ì´íŠ¸
                            const networkResponse = await fetch('/api/analytics/network-metrics?timeRange=6h');
                            if (networkResponse.ok) {
                                const networkResult = await networkResponse.json();
                                if (networkResult.success && networkResult.data.length > 0) {
                                    const latestNetwork = networkResult.data[networkResult.data.length - 1];
                                    latestNetwork.timestamp = new Date();
                                    dashboardData.network.push(latestNetwork);
                                    if (dashboardData.network.length > 30) dashboardData.network.shift();
                                }
                            }
                        }
                        
                        // ì´ìƒ íƒì§€ ë°ì´í„° ì—…ë°ì´íŠ¸
                        const anomalyResponse = await fetch('/api/analytics/anomaly-detection?timeRange=6h');
                        if (anomalyResponse.ok) {
                            const anomalyResult = await anomalyResponse.json();
                            if (anomalyResult.success && anomalyResult.data.length > 0) {
                                // ìƒˆë¡œìš´ ì´ìƒ íƒì§€ í¬ì¸íŠ¸ ì‹œë®¬ë ˆì´ì…˜
                                const now = new Date();
                                const baseValue = 100 + Math.sin(Date.now() * 0.001) * 20;
                                const isAnomaly = Math.random() < 0.05;
                                const value = isAnomaly ? baseValue + (Math.random() - 0.5) * 100 : baseValue + (Math.random() - 0.5) * 20;
                                
                                dashboardData.anomalies.push({
                                    timestamp: now,
                                    value: Math.max(0, value),
                                    predicted: baseValue,
                                    isAnomaly: isAnomaly,
                                    anomalyScore: isAnomaly ? 0.7 + Math.random() * 0.3 : Math.random() * 0.3,
                                    confidence: 0.85 + Math.random() * 0.15
                                });
                                if (dashboardData.anomalies.length > 100) dashboardData.anomalies.shift();
                            }
                        }
                        
                        // ì°¨íŠ¸ ë° ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
                        updateAllCharts();
                        await updateMetricCards();
                        
                        console.log('âœ… ì‹¤ì‹œê°„ ë°ì´í„° ì—…ë°ì´íŠ¸ ì™„ë£Œ');
                        
                    } catch (error) {
                        console.error('âŒ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', error);
                        // í´ë°±: ë¡œì»¬ ë°ì´í„° ìƒì„±
                        fallbackRealTimeUpdate();
                    }
                }
            }, 5000); // 5ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
        }
        
        // í´ë°± ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
        function fallbackRealTimeUpdate() {
            const now = new Date();
            
            // APP ë°ì´í„° ì¶”ê°€
            dashboardData.app.push({
                timestamp: now,
                value: 150 + Math.random() * 100 + Math.sin(Date.now() * 0.001) * 20,
                responseTime: 150 + Math.random() * 100,
                source: 'clickhouse'
            });
            if (dashboardData.app.length > 50) dashboardData.app.shift();
            
            // ì¸í”„ë¼ ë°ì´í„° ì¶”ê°€
            const cpu = 30 + Math.random() * 40;
            const memory = 40 + Math.random() * 30;
            const disk = 20 + Math.random() * 25;
            
            dashboardData.infra.push({
                timestamp: now,
                cpu: cpu,
                memory: memory,
                disk: disk
            });
            if (dashboardData.infra.length > 60) dashboardData.infra.shift();
            
            // ì°¨íŠ¸ ì—…ë°ì´íŠ¸
            updateAllCharts();
            updateMetricCardsFallback();
        }

        // ì»¨íŠ¸ë¡¤ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        function setupControlListeners() {
            document.getElementById('timeRangeSelect').addEventListener('change', function() {
                console.log('ğŸ”„ ì‹œê°„ ë²”ìœ„ ë³€ê²½:', this.value);
                // ì‹œê°„ ë²”ìœ„ì— ë”°ë¥¸ ë°ì´í„° ì¬ë¡œë“œ
                loadInitialData();
            });

            document.getElementById('dataSourceSelect').addEventListener('change', function() {
                console.log('ğŸ”„ ë°ì´í„° ì†ŒìŠ¤ ë³€ê²½:', this.value);
                // ë°ì´í„° ì†ŒìŠ¤ì— ë”°ë¥¸ APP ë°ì´í„° ì¬ë¡œë“œ
                loadAppData().then(() => {
                    updateAllCharts();
                    updateMetricCards();
                });
            });

            document.getElementById('aggregationSelect').addEventListener('change', function() {
                console.log('ğŸ”„ ì§‘ê³„ ë‹¨ìœ„ ë³€ê²½:', this.value);
                // ì§‘ê³„ ë‹¨ìœ„ì— ë”°ë¥¸ ë°ì´í„° ì²˜ë¦¬ (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” API íŒŒë¼ë¯¸í„°ë¡œ ì „ë‹¬)
                loadInitialData();
            });
            
            // ì‹¤ì‹œê°„ ëª¨ë“œ í† ê¸€ (ì„ íƒì )
            const realTimeToggle = document.createElement('button');
            realTimeToggle.textContent = 'ì‹¤ì‹œê°„ ëª¨ë“œ: ON';
            realTimeToggle.className = 'control-select';
            realTimeToggle.style.marginLeft = 'auto';
            realTimeToggle.onclick = () => {
                isRealTimeMode = !isRealTimeMode;
                realTimeToggle.textContent = `ì‹¤ì‹œê°„ ëª¨ë“œ: ${isRealTimeMode ? 'ON' : 'OFF'}`;
                realTimeToggle.style.background = isRealTimeMode ? '#3b82f6' : '#6c757d';
                realTimeToggle.style.color = 'white';
                console.log('ğŸ”„ ì‹¤ì‹œê°„ ëª¨ë“œ:', isRealTimeMode ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”');
            };
            
            const controlsContainer = document.querySelector('.chart-controls');
            if (controlsContainer && !controlsContainer.querySelector('button[onclick]')) {
                controlsContainer.appendChild(realTimeToggle);
            }
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ğŸš€ í†µí•© ë¶„ì„ ëŒ€ì‹œë³´ë“œ ë¡œë“œ ì‹œì‘...');
            
            // D3.js ë¡œë“œ í™•ì¸
            if (typeof d3 === 'undefined') {
                console.error('âŒ D3.jsê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!');
                return;
            }
            console.log('âœ… D3.js v' + d3.version + ' ë¡œë“œ ì™„ë£Œ');
            
            // SVG ìš”ì†Œ í™•ì¸
            const svgElements = document.querySelectorAll('.chart-svg');
            console.log('ğŸ“Š ë°œê²¬ëœ SVG ì°¨íŠ¸ ìš”ì†Œ:', svgElements.length);
            svgElements.forEach((svg, index) => {
                console.log(`  - ${index + 1}. ${svg.id}: ${svg.getBoundingClientRect().width}x${svg.getBoundingClientRect().height}`);
            });
            
            // ê³µí†µ ë ˆì´ì•„ì›ƒ ë¡œë“œ ëŒ€ê¸°
            setTimeout(() => {
                console.log('ğŸ¯ ëŒ€ì‹œë³´ë“œ ì´ˆê¸°í™” ì‹œì‘...');
                initializeDashboard();
            }, 500);
        });

        // ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ ì²˜ë¦¬
        window.addEventListener('resize', function() {
            // ì°¨íŠ¸ í¬ê¸° ì¡°ì •
            setTimeout(() => {
                initializeDashboard();
            }, 100);
        });
    </script>
</body>
</html>