# AIRIS EPM Database Secrets and Credentials
# Secure credential management for all database systems

# ClickHouse Credentials
apiVersion: v1
kind: Secret
metadata:
  name: clickhouse-credentials
  namespace: airis-epm
  labels:
    app: clickhouse
    component: credentials
type: Opaque
stringData:
  password: "airis-epm-clickhouse-prod-2025"
  airis-password: "airis-epm-user-strong-pass-2025"
  readonly-password: "airis-epm-readonly-pass-2025"

---
# PostgreSQL Credentials
apiVersion: v1
kind: Secret
metadata:
  name: postgresql-credentials
  namespace: airis-epm
  labels:
    app: postgresql
    component: credentials
type: Opaque
stringData:
  postgres-password: "airis-epm-postgres-super-2025"
  admin-password: "airis-epm-admin-strong-2025"
  replicator-password: "airis-epm-repl-secure-2025"

---
# Redis Credentials
apiVersion: v1
kind: Secret
metadata:
  name: redis-credentials
  namespace: airis-epm
  labels:
    app: redis
    component: credentials
type: Opaque
stringData:
  password: "airis-epm-redis-cluster-2025"

---
# MongoDB Credentials
apiVersion: v1
kind: Secret
metadata:
  name: mongodb-credentials
  namespace: airis-epm
  labels:
    app: mongodb
    component: credentials
type: Opaque
stringData:
  root-password: "airis-epm-mongo-root-2025"
  airis-password: "airis-epm-mongo-user-2025"
  admin-ui-password: "airis-epm-mongo-ui-2025"

---
# MongoDB Keyfile for Replica Set Authentication
apiVersion: v1
kind: Secret
metadata:
  name: mongodb-keyfile
  namespace: airis-epm
  labels:
    app: mongodb
    component: keyfile
type: Opaque
stringData:
  mongodb-keyfile: |
    airis-epm-mongodb-replica-set-keyfile-2025-secure-authentication-key-for-internal-cluster-communication-and-replica-set-coordination-this-key-must-be-identical-across-all-replica-set-members-and-should-be-kept-highly-secure-change-this-in-production

---
# ClickHouse TLS Certificate
apiVersion: v1
kind: Secret
metadata:
  name: clickhouse-tls-secret
  namespace: airis-epm
  labels:
    app: clickhouse
    component: tls
type: kubernetes.io/tls
data:
  tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURhekNDQWxPZ0F3SUJBZ0lKQUoxWjJGZ2V4WFlUTUEwR0NTcUdTSWIzRFFFQkN3VUFNRjh4Q3pBSkJnTlYKQkFZVEFsVlRNUXN3Q1FZRFZRUUlEQUpEUVRFZE1Cc0dBMVVFQnd3VVJHVm1ZWFZzZENCVGRHRjBaVU5wZEhreApGREFTQmdOVkJBb01DMEZKVWtsVElFVlFUVEVPTUF3R0ExVUVBd3dGWVdsc2FXNW5NQjRYRFRJME1EVXhOREV6Ck5EZ3pOMW9YRFRJMU1EVXhOREV6TkRnek4xb3dmVEVMTUFrR0ExVUVCaE1DVlZNeEN6QUpCZ05WQkFnTUFrTkJKCk1SMHdHd1lEVlFRSERCUkVaV1poZFd4MElGTjBZWFJsUTJsMGVURVVNQklHQTFVRUNnd0xRVWxTU1ZNZ1JWQk4KTVE0d0RBWURWUVFEREFWaGFXeGhibWN3Z2dFaU1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQ0R3QXdnZ0VLQW9JQwpBUURrL0VLa2c5dVJMTUIrRFVsVDU5K0tqNzJMdGpRR1AyOUxkMkxWSkJxMW5uV0laWlZUOWIzWjUxZDJDV25ECnI2R0hEQXl3QmtLdDBDbkRWKzZINk5iTytmZGdJZzI4UXNHbUZwcGlaQm1tLzF6TEFjZzk5M05QeWRGNlY3YkIKUDFxcmVtWGluYWdCS0hjS3VYT2tGZXZ1dkpRMlcrVTEzUEUvYW5DTjFPOEtpQm9GdGJBcm53Mm5HbVY3Q1JLTAorSG9jWGgvS3QzTGlkYWRqR2QxdENGRUxzTXdueC9zU29RaUg5SkJFZWdyZ1hzNjRqR3kwZWNsVll4RXRHRWpKCmdnVkJiVTZueFgzYkhNNWVOUnBSZEQzN0I1OTRvZGQzUVFQa0RxVzNjM0FWZDl5d21IN2RrdW44cStyb2p2L3EKbDNrT1d5UXRhWVZNSEdlazZsSkpINEVzRFFhZkZhVzJKSWR6WXI1cklzM01MeGZlNkZJNUlERkEvMStTM0hySQpZSGFjYWFFRG90QkN3OWJwbjU2eCtWa2FQaElnOTVPNFhORE5BQzN5SStvcW9XeGtWWUZkQTJ6VWtGVDBYREhuCnZBTC9LQTFsU2JRWE1SUDA3VFJ4UFlUc2dHcmRUbTJqRTRvdjRzMU9raUIrWU1PT3plZ2tEKzExOFFKVWJySUoKRmg0ZVN6c3JtV25XWGdBZ1Z2V09sSkU2cXM3dXFNdVp6Z1MzcU9MaXRQVGY4d0Erb21kRm5wTjcrc29HWVhOagoycUJiUWMyemowRFMzeFl1dEkvSDJoNFk3cDN2cG1wUkNOUDRveUt1bk1Qa3pWNzJxeEFIUVROMkI5Wlg2K1Z0CkplcHlSZDNjT0VCOWJ5UExnTW0vbDd2dU01T0xaRlFjN085V25wd0lEQVFBQm8xTXdVVEFkQmdOVkhRNEVGZ1EKVWhvWGRwUXpyQVlKTUtZUUlRY0JCUU1oUkdzeENEQWZCZ05WSFNNRUdEQVdnQlJoQVU5MVRWTEMwdWlmSE1YUQpBSlF6VFIzK3R6Q0JnTlZIUkVCeS5LSUFJdEFEWkZRVkUvZ3FzZ09pREFQQmd0YmtZTjUySGo5cFlOMmhHN0RTCnRBSFpiTTlLRGZOejE5YU9wZWRLRnZBSU8rWTNHUDhEWWJRUzFJaWVidGJaYzF6NE93RmdDWGUvREM5ZHVzQWkKMjhRc0dtRnBwaXdnRHllSEYzNWpuek1jRUZZd3FwOXdSeXEyYXJnZ2t4SlNUaVdLOGNCaXhmQ0c3T2ZKaTB6bgptR2RnWGFweXRqb1E2K0ZqQlZYZTFBRVdkZWFJaFJ1YmdvQUxqU2lrY0ZzWTRZRHJIZUFBVFpxZmluTzFmQmJlCmJzeVAySlltLzRmUmFZUTNyMmU2Lzg1U2dZUmYzVU5SQmlSaW5oN3BTLzM4WXE3RHJLcE1lMjFuYmdkTklCdjQKMXBrZmd5bkZ0QUVEY01uSVNuczVzNnU4ZzV5VUlITmg1YmZEMTlXcGJZNW5XQlI1QjdLNndHQQpPSG5sUlVVcVNPQWNkNkNNOGRuNXdRZ2c1bExnNUJkRmJJZXBNdnJETzdDa1BRS3drbkNVaW9jbDVhWUUrNVVrCjMwRDd5bjhOWnFhMUN6VnMwQjJJejVSTWhQK1JaUXN3M2MyeW9hUk0rbFBoTXJNQkh6ek1MYzM1U05BVEdVRTMKUkJGNWlRYWFjbGJEZ1U3VGJSYlh0SFVlMDdBUUx2UzJCU0F3dzRscThIT0lOSTNsRWNOdXA1RCtYU3Qxd2xzSAoxN20yMVhHUGZ5SGFxclE1cG84K3FKRUJjUTNiMHEyUEJadVJGaTFJSkJqYm1qcGJROWZ1Q2p5VWpGTC8vS1JiCm4ydStTUUNNVnNIaG9FKUE2VW5GOXpoYU8wbVl6SEVlaEdYdG5lNmRWWktBdzNlRjdBSGphTkNhQ0JCMVBmQXIKQldzalN3NHVhb3plOFY0V1NqeUEKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQ==
  tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2Z0lCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktnd2dnU2tBZ0VBQW9JQkFRRGsvRUtrZzl1UkxNQisKRFVsVDU5K0tqNzJMdGpRR1AyOUxkMkxWSkJxMW5uV0laWlZUOWIzWjUxZDJDV25EcjZHSERBeXdCa0t0MENuRAoKVSs2SDZOYk8rZmRnSWcyOFFzR21GcHBpWkJtbS8xekxBY2c5OTNOUHlkRjZWN2JCUDFxcmVtWGluYWdCS0hjCktNWE9rRmV2dXZKUTJXK1UxM1BFL2FuQ04xTzhLaUJvRnRiQXJudzJuR21WN0NSSUwrSG9jWGgvS3QzTGlkYWQKSgpHZDF0Q0ZFTHNNd254L3NTb1FpSDlKQkVlZ3JnWHM2NGpHeWVlY2xWWXhFdEdFakunNnZCYlU2bnhYM2JITTVlCk5ScFJkRDM3QjU5NG9kZDNRUVBrRHFXM2MzQVZkOXl3bUg3ZGt1bjhxK3JvanYvcWwza09XeVF0YVlWTUhHZWsKNmxKSkg0RXNEUWFmRmFXMkpJZHpZcjVySXMzTUx4ZmU2Rkg1SURGQSsxK1MzSHJJWUhhY2FhRURvdEJDdDliCnBuNTZ4K1ZrYVBoSWc5NTg0WE5ETkFDM3lJK29xb1d4a1ZZRmRBMnpVa0ZUMFhESG52QUwvS0ExbFNiUVhNUlAKMDdUUnhQWVRzZ0dyZFRtMmpFNG92NHMxT2tpQitZTU9PemVna0QrMTE4UUpVYnJJSkZoNGVTenNybVduV1hnQQpnVnZXT2xKRTZxczd1cU11WnpnUzNxT0xpdFBUZjh3QStvbWRGbnBONytib0dZWE5qMnFCYlFjMnpqMERTM3hZCnV0SS9IMmg0WTdwM3ZwbXBSQ05QNG95S3VuTVBrelY3MnF4QUhRVE4yQjlaWDYrVnRKZXB5UmQzY09FQjlieVAKTGdNbS9sN3Z1TTVET1pGUWM3TzlXbnB3SURBUUFCQW9JQkFGeFBzbzVrSlZqZUhQSHRINll4Z3Y2VzJpeVdXVQpuWVl3SzBsZVRHU2R4eW9qZnQ4T29KKzNZV0w2ZCttRGVjemhlQUp2YVhYWUtOOWVMVDd5VFcyT0dWR05NMXA4CktHY0ZGVHhEYkpnZ3NsM04rYk8xbWpvK3dCZHo0WCs3ZWFqcnM3Rmd5bnVLVWZEcGNHWnc5QWNuSjkxL0lvUU8KMStaUGh1eDNab3A2UWdBbDFhUVo3RjlmdTJVTGsrQVNGWnJGN2JyVXQ5OHMyL2VTVVhNeE9TUC92OHlnUnNRawpkaWJOS0dDZDFEV1MvcW1nK05TQXNvUVA4WVo5Sng1dE1yUVEyb3VmUVF2N1NvOWgxSUJ1SHRtU09vc3dLUjBKCnFLYy9TZDQvS2Y4T3M2c2F2QkFRNVZpVkZjNkdMUEYzQnZucGhFRUpjRU9Bd3Roc2tuRjNLRXNDZ1lFQTlHdXMKd1E3dDZSUExyNWRTbjFjdnNzV2xhbFRhRmFJSWZYQ09BT0lNb2lzOEdBdGI5SnFEaG83cWFVb2JRUERJZ2w0WgpOa01LaVRJbW9ZRWw4Z2Q4ZGJMM3ZxUE85c3ZZNFl3Nmo5UmlGaUNyZHZmRHhiQ1dzc3lRUjIvT3p4Qk13cGFCCno3V3U5bnNBVVdJU0FLZFl2YUp5R21xblA0SlZjL3liU2tQWGNDa0NnWUVBOHFrWjJZUTkvaXI1Q2M3ZDFYYTQKMC9ONE1nUzNRczNZa1Z0UG9TRThyZXptbE5zQU8vUjMrMVcvQnE5REJVZklUczRNY0Q3Q1NpNEJJY2JzSEtQWgpwQy9tZHFGOTNsZU9wV3doKzJDVUV4azVTa3M5Z3lqcGpyR0s3R3NsUTVYT25TNUN2K0RkaDJKK1hVY01tSy9JCjVma3Y4VlNNWDU1WW1WZExBdjNXYWswQ2dZRUF4c0JxcTExVVIvSVJRNHI5ZWZWZWpOR2NEMEVOdjJWejNxckwKdWpmNXRYOFlFUWxZRzJvR1NnQUFVaXQ1U1FhdmtzUXYvcnhqQWRkVkhTOVpsWlE5OXVVaTFEOStSa0NKNVU1YgoxN0FkS3piUDIrMGJLdjZhQUFBWFpwdElVTFNOejZXUE80MlZzWUZ0VmVGNVhCYm9OOWdNWFFZajJMcTFkODFCCk9IOFJsUFlDZ1lFQW5PVDhmQUl6ejJmZVVpOGJ1YVQzUnlNNzJJdXlTVlV1M0tCdStjVkJHb05jOGFIR0QxazkKMWx1MXNUUm5weUhpU2RZTU93WGFpUFdqUDFJdEQxdGNXTzdIWE90aExrMjBiRXl2S2VHRjdHY3VoLytCVWl5RAo4aFRHYkNIazZMdC9ONG82N1Y3dkRmTGNJLzI4TVQ5ZEVaUnNSdDQvb1RNKy9JcXVmOUVDZ1lCZTc3UnhQYnNlCnl5aXRoU3FZVFdEWGtFSlhCUDZySlNjcFNZc0huK01FZlowRVBsRjVCVkUvSFp2WUppNG0zcjV1dTFYSVNzZmIKekJZUUpHWnQyL2duVjlUaDdac2hLbloxTXZxdGNyb2RmZS8ycytWL0lJcDE2YWIxd0VQVFc3RHZhVks4amdxUwpDUFU5dEowTC9LTnNJSCtZSWxVRHNPYlZGZXpoYWxtWmJBPT0KLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLQ==

---
# Storage Class for Fast SSD
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast-ssd
  labels:
    app: storage
    component: ssd
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp3
  iops: "3000"
  throughput: "125"
  fsType: ext4
volumeBindingMode: WaitForFirstConsumer
allowVolumeExpansion: true
reclaimPolicy: Retain

---
# Database Connection Pool ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: database-connection-config
  namespace: airis-epm
  labels:
    app: airis-epm
    component: database-config
data:
  database-config.json: |
    {
      "clickhouse": {
        "cluster": {
          "hosts": [
            "clickhouse-0.clickhouse-headless.airis-epm.svc.cluster.local:8123",
            "clickhouse-1.clickhouse-headless.airis-epm.svc.cluster.local:8123",
            "clickhouse-2.clickhouse-headless.airis-epm.svc.cluster.local:8123",
            "clickhouse-3.clickhouse-headless.airis-epm.svc.cluster.local:8123"
          ],
          "load_balancer": "clickhouse-lb.airis-epm.svc.cluster.local:8123",
          "database": "airis_epm",
          "username": "airis_epm_user",
          "ssl": true,
          "pool_size": 20,
          "timeout": 30000,
          "retry_attempts": 3
        }
      },
      "postgresql": {
        "primary": {
          "host": "postgresql-primary.airis-epm.svc.cluster.local:5432",
          "database": "airis_epm",
          "username": "admin",
          "ssl": true,
          "pool_size": 20,
          "timeout": 30000,
          "max_lifetime": 3600000
        },
        "replica": {
          "host": "postgresql-replica.airis-epm.svc.cluster.local:5432",
          "database": "airis_epm",
          "username": "admin",
          "ssl": true,
          "pool_size": 10,
          "timeout": 30000,
          "readonly": true
        }
      },
      "redis": {
        "cluster": {
          "hosts": [
            "redis-0.redis-headless.airis-epm.svc.cluster.local:6379",
            "redis-1.redis-headless.airis-epm.svc.cluster.local:6379",
            "redis-2.redis-headless.airis-epm.svc.cluster.local:6379",
            "redis-3.redis-headless.airis-epm.svc.cluster.local:6379",
            "redis-4.redis-headless.airis-epm.svc.cluster.local:6379",
            "redis-5.redis-headless.airis-epm.svc.cluster.local:6379"
          ],
          "load_balancer": "redis-lb.airis-epm.svc.cluster.local:6379",
          "pool_size": 10,
          "timeout": 5000,
          "retry_attempts": 3,
          "retry_delay": 1000
        }
      },
      "mongodb": {
        "replica_set": {
          "hosts": [
            "mongodb-0.mongodb-headless.airis-epm.svc.cluster.local:27017",
            "mongodb-1.mongodb-headless.airis-epm.svc.cluster.local:27017",
            "mongodb-2.mongodb-headless.airis-epm.svc.cluster.local:27017"
          ],
          "replica_set_name": "airis-epm-rs",
          "primary": "mongodb-primary.airis-epm.svc.cluster.local:27017",
          "database": "airis_epm",
          "username": "airis_epm_user",
          "pool_size": 10,
          "timeout": 30000,
          "retry_writes": true,
          "read_preference": "primaryPreferred"
        }
      }
    }

  connection-test.js: |
    // Database connection test script for AIRIS EPM
    const config = require('./database-config.json');
    
    async function testClickHouse() {
      const { ClickHouse } = require('@clickhouse/client');
      
      const client = new ClickHouse({
        host: config.clickhouse.cluster.load_balancer,
        username: config.clickhouse.cluster.username,
        password: process.env.CLICKHOUSE_PASSWORD,
        database: config.clickhouse.cluster.database,
        clickhouse_settings: {
          max_execution_time: 30
        }
      });
      
      try {
        const result = await client.query({ 
          query: 'SELECT version() as version, now() as current_time' 
        });
        const data = await result.json();
        console.log('✅ ClickHouse connection successful:', data);
        return true;
      } catch (error) {
        console.error('❌ ClickHouse connection failed:', error.message);
        return false;
      }
    }
    
    async function testPostgreSQL() {
      const { Client } = require('pg');
      
      const client = new Client({
        host: config.postgresql.primary.host.split(':')[0],
        port: config.postgresql.primary.host.split(':')[1],
        database: config.postgresql.primary.database,
        user: config.postgresql.primary.username,
        password: process.env.POSTGRES_PASSWORD,
        ssl: config.postgresql.primary.ssl
      });
      
      try {
        await client.connect();
        const result = await client.query('SELECT version(), now()');
        console.log('✅ PostgreSQL connection successful:', result.rows[0]);
        await client.end();
        return true;
      } catch (error) {
        console.error('❌ PostgreSQL connection failed:', error.message);
        return false;
      }
    }
    
    async function testRedis() {
      const Redis = require('ioredis');
      
      const redis = new Redis.Cluster(
        config.redis.cluster.hosts.map(host => {
          const [hostname, port] = host.split(':');
          return { host: hostname, port: parseInt(port) };
        }),
        {
          redisOptions: {
            password: process.env.REDIS_PASSWORD
          },
          maxRetriesPerRequest: config.redis.cluster.retry_attempts
        }
      );
      
      try {
        await redis.set('test:connection', 'success');
        const result = await redis.get('test:connection');
        console.log('✅ Redis connection successful:', result);
        await redis.del('test:connection');
        redis.disconnect();
        return true;
      } catch (error) {
        console.error('❌ Redis connection failed:', error.message);
        return false;
      }
    }
    
    async function testMongoDB() {
      const { MongoClient } = require('mongodb');
      
      const url = `mongodb://${config.mongodb.replica_set.username}:${process.env.MONGODB_PASSWORD}@${config.mongodb.replica_set.hosts.join(',')}/${config.mongodb.replica_set.database}?replicaSet=${config.mongodb.replica_set.replica_set_name}`;
      
      const client = new MongoClient(url, {
        maxPoolSize: config.mongodb.replica_set.pool_size,
        serverSelectionTimeoutMS: config.mongodb.replica_set.timeout
      });
      
      try {
        await client.connect();
        const db = client.db(config.mongodb.replica_set.database);
        const result = await db.admin().ping();
        console.log('✅ MongoDB connection successful:', result);
        await client.close();
        return true;
      } catch (error) {
        console.error('❌ MongoDB connection failed:', error.message);
        return false;
      }
    }
    
    async function runAllTests() {
      console.log('🔍 Testing database connections...\n');
      
      const results = await Promise.allSettled([
        testClickHouse(),
        testPostgreSQL(), 
        testRedis(),
        testMongoDB()
      ]);
      
      const successful = results.filter(r => r.status === 'fulfilled' && r.value).length;
      const total = results.length;
      
      console.log(`\n📊 Connection test results: ${successful}/${total} successful`);
      
      if (successful === total) {
        console.log('🎉 All database connections are healthy!');
        process.exit(0);
      } else {
        console.log('⚠️  Some database connections failed. Check logs above.');
        process.exit(1);
      }
    }
    
    if (require.main === module) {
      runAllTests().catch(console.error);
    }
    
    module.exports = {
      testClickHouse,
      testPostgreSQL,
      testRedis,
      testMongoDB,
      runAllTests
    };